---
title: "Learning How to Learn: The Novice Developer's Tool Belt"
date: 2015-06-19
tags:
author: Morgan Miller
layout: post
---

There are dozens, perhaps hundreds, even maybe one <em>million</em> ways to attempt to learn how to code. And they aren’t all great.

Most beginners’ track tutorials entail hand-holdy instructions, nifty in-browser interpreters and a swift sense of accomplishment, but rarely do they breed a developer’s mindset. On the other hand, intermediate-level walkthroughs and Stackoverflow threads often assume too much contextual knowledge for a beginner to follow.

A giant chasm of confusion exists between finishing your first Ruby tutorial and deploying your first app to production. I know this to be true, because those “tutorial blues” are why I applied to Turing in the first place.

After three months of using tutorials to learn Python, then Ruby, I could hardly conceptualize what a completed project in either language would look like – let alone write one. It was frustrating to sail through my umpteenth online course but still have no idea how to take that leap into <em>actually coding.</em>

Then, after a whirlwind six weeks at Turing, I began my first personal side project in collaboration with Josh Cheek. As an instructor who advocates experimentation as a tool to discovery, he challenged me to use Sinatra, ActiveRecord, REST Client, RAKE, and a lot of other frameworks and concepts that were completely foreign to me. But the challenges weren’t unconquerable. I realized that in those six weeks, while I hadn’t necessarily learned how to capital-C “Code,” I had learned how to <em>learn</em> how to code.

Learning how to code all comes down to growing your developer’s tool belt: stocking it with gadgets that can be used to gradually demystify all of the daunting, unfamiliar concepts that lurk in the chasm of confusion. Because everyone keeps telling me that you never reach a point where you have all the answers. You just get better at figuring them out. You know, with your tool belt.

Here is what six weeks at Turing lent to my Ruby tool belt:

**1. The Mighty Hammer of Debugging**

They say that when all you have is a hammer, everything starts to look like a nail. But let’s just say that every test error or failure IS a nail… Then a hammer comes in pretty handy, right?

For Ruby and Rails, my debugging hammer is <a href=”http://pryrepl.org/”>Pry</a>. Put ‘pry’ in your Gemfile and stick a binding anywhere you want to interact with your code. Prying around is kind of like freezing time, falling into the matrix of your program, and moving the time-frozen objects around with your bare hands to see how they fall. Except instead it’s in your terminal, with an IRB-style interface and your keyboard.

**2. X-Ray Glasses**

The power to see what’s happening with your code, line by line, is undeniable. Josh Cheek’s <a href=”https://github.com/JoshCheek/seeing_is_believing”>Seeing Is Believing</a> tool is basically to Rubyists what every electrician probably wishes they had to see through walls. It evaluates each line of code right inside of your editor, which can save a lot of time and be a generally enlightening experience.

**3. The Google Dictionary**

Knowing how to search for something is definitely a tool. And when you’re first learning how to code, you just don’t have the vernacular to posit a sensible query to a search engine. Google probably doesn’t know how to “make a list thing change into the other list thing ruby stackoverflow.” But it can tell you how to “convert a Ruby array into a hash.” Get your basic vocabulary down by reading beginner’s books (I like <em>Eloquent Ruby</em>), and you’ll be fluent enough to get the help you need from the mythical search engine spiders.

If the problem is your project itself, pseudo-code it from start to finish and tackle each sub-issue on your list in isolation. If the problem is working with a brand new gem that you’ve never used before, then make a list of all of your ‘unknowns.’ What Classes are you working with and what behaviors do they have? What methods do you need? What can you pass into those methods, what do those methods return to you? Take each unknown one-at-a-time, and apply the simplest use cases you can think of to find your answers.

**5. The Guess-O-Meter**

This one definitely requires a sense of humor and a comfort with being wrong more than you are right. Lately, I use it a lot for command line flags and ActiveRecord methods (which is probably just a testimony to how intuitive ActiveRecord is).

The act of guessing is powerful for two reasons: First, it requires what I like to think of as ‘active learning.’ It’s easy to Google the answer, and even easier to copy-and-paste. But that’s passive, and you’re less likely to retain it. When you force yourself to think critically about something you know nothing about, you’re forcing yourself to make sense of it. Those are the things you will remember later on.

Secondly, when you’re right it’s sort of… life affirming. It’s easy to doubt your own competence when you’re learning a new skill, and it’s the little victories that help build the momentum it takes to stay in the zone and keep cramming new knowledge into your brain.

So there’s all that I’ve learned so far about learning how to code. Do I totally know how to code now? No. Nope, I do not. The good people that belong to Turing’s staff and mentor network still have a lot left to teach me, and while they do, I pretty much have a permanent residence in that chasm of confusion. But at least it’s looking less like a terror-ridden desert canyon, and more like a sandbox that I get to play around in for a while.

---

**Morgan Miller** is a student in the 1503 cohort. She is finishing up her second module at Turing. You can follow here at [@thenmorgsaid](https://twitter.com/thenmorgsaid).
